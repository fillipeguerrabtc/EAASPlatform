MARKETING — COMPLETO
0) Dependências (adicione se faltarem)
{
  "dependencies": {
    "handlebars": "^4.7.8",
    "nodemailer": "^6.9.14",
    "twilio": "^5.3.3",
    "bullmq": "^5.9.1",
    "ioredis": "^5.4.1",
    "zod": "^3.23.8"
  }
}

Variáveis .env necessárias
PRIMARY_TENANT_ID=tenant_0001

# Email (SMTP) — pode ser Mailtrap, Gmail, Sendgrid SMTP etc.
SMTP_HOST=smtp.mailtrap.io
SMTP_PORT=2525
SMTP_USER=seu_user
SMTP_PASS=seu_pass
SMTP_FROM="Yes You Deserve! <no-reply@yesyoudeserve.tours>"

# Twilio (WhatsApp)
TWILIO_ACCOUNT_SID=ACxxxxxxxxxxxxxxxx
TWILIO_AUTH_TOKEN=xxxxxxxxxxxx
TWILIO_WHATSAPP_FROM=whatsapp:+14155238886

# Redis (fila)
REDIS_URL=redis://localhost:6379

1) Schema (Drizzle) — templates, campanhas, envios, eventos, preferências LGPD

Arquivo: shared/schema.marketing.ts

// shared/schema.marketing.ts
import {
  pgTable, uuid, varchar, text, integer, boolean, timestamp, index, pgEnum
} from "drizzle-orm/pg-core";

export const mkChannelEnum = pgEnum("mk_channel", ["email","whatsapp","facebook","instagram"]);
export const mkStatusEnum  = pgEnum("mk_status", ["draft","scheduled","running","paused","finished","failed"]);

export const mkTemplates = pgTable("mk_templates", {
  id: uuid("id").primaryKey().defaultRandom(),
  tenantId: varchar("tenant_id",{length:64}).notNull(),
  name: varchar("name",{length:160}).notNull(),
  channel: mkChannelEnum("channel").notNull(),
  subject: varchar("subject",{length:240}), // email
  bodyHandlebars: text("body_hbs").notNull(), // corpo handlebars
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
}, t => ({
  idxTenant: index("mk_tpl_tenant_idx").on(t.tenantId),
  idxChan: index("mk_tpl_chan_idx").on(t.channel),
}));

export const mkCampaigns = pgTable("mk_campaigns", {
  id: uuid("id").primaryKey().defaultRandom(),
  tenantId: varchar("tenant_id",{length:64}).notNull(),
  name: varchar("name",{length:160}).notNull(),
  channel: mkChannelEnum("channel").notNull(),
  templateId: uuid("template_id").notNull(),
  // segmentação
  segmentId: uuid("segment_id"),        // usa engine dos segments do CRM
  manualAudienceJson: text("manual_audience_json"), // fallback: [{contactId, email/phone}]
  // A/B
  abVariantBTemplateId: uuid("ab_b_tpl_id"),
  abSplitPercent: integer("ab_split_percent").default(0).notNull(), // 0..50 (% vai para B)
  // throttle e limites
  throttlePerMin: integer("throttle_per_min").default(600).notNull(),
  maxSends: integer("max_sends"),
  // agendamento
  status: mkStatusEnum("status").default("draft").notNull(),
  scheduledAt: timestamp("scheduled_at"),
  startedAt: timestamp("started_at"),
  finishedAt: timestamp("finished_at"),
  // conteúdo dinâmico opcional
  defaultDataJson: text("default_data_json"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
}, t => ({
  idxTenant: index("mk_cpg_tenant_idx").on(t.tenantId),
  idxStatus: index("mk_cpg_status_idx").on(t.status),
}));

export const mkSends = pgTable("mk_sends", {
  id: uuid("id").primaryKey().defaultRandom(),
  tenantId: varchar("tenant_id",{length:64}).notNull(),
  campaignId: uuid("campaign_id").notNull(),
  contactId: uuid("contact_id"),
  toAddress: varchar("to_address",{length:240}),
  channel: mkChannelEnum("channel").notNull(),
  templateId: uuid("template_id").notNull(),
  // A/B metadata
  abVariant: varchar("ab_variant",{length:1}).default("A").notNull(), // "A"|"B"
  // provider ids
  providerMessageId: varchar("provider_msg_id",{length:240}),
  // estado de envio
  sentAt: timestamp("sent_at"),
  error: text("error"),
  createdAt: timestamp("created_at").defaultNow().notNull()
}, t => ({
  idxTenant: index("mk_sends_tenant_idx").on(t.tenantId),
  idxCampaign: index("mk_sends_cpg_idx").on(t.campaignId),
}));

export const mkEvents = pgTable("mk_events", {
  id: uuid("id").primaryKey().defaultRandom(),
  tenantId: varchar("tenant_id",{length:64}).notNull(),
  sendId: uuid("send_id").notNull(),
  type: varchar("type",{length:24}).notNull(), // delivered|opened|clicked|replied|bounced|failed
  meta: text("meta"),
  createdAt: timestamp("created_at").defaultNow().notNull()
}, t => ({
  idxTenant: index("mk_evt_tenant_idx").on(t.tenantId),
  idxSend: index("mk_evt_send_idx").on(t.sendId),
}));

// Preferências/Opt-in LGPD por contato
export const contactPreferences = pgTable("contact_preferences", {
  tenantId: varchar("tenant_id",{length:64}).notNull(),
  contactId: uuid("contact_id").notNull(),
  emailOptIn: boolean("email_optin").default(true).notNull(),
  whatsappOptIn: boolean("whatsapp_optin").default(true).notNull(),
  facebookOptIn: boolean("facebook_optin").default(false).notNull(),
  instagramOptIn: boolean("instagram_optin").default(false).notNull(),
  quietHoursStart: integer("quiet_start").default(22), // 22h
  quietHoursEnd: integer("quiet_end").default(8),      // 08h
  updatedAt: timestamp("updated_at").defaultNow().notNull()
}, t => ({
  idx: index("contact_prefs_idx").on(t.tenantId, t.contactId)
}));

2) Validadores (Zod)

Arquivo: server/modules/marketing/validators.ts

import { z } from "zod";

export const templateUpsertSchema = z.object({
  id: z.string().uuid().optional(),
  name: z.string().min(1),
  channel: z.enum(["email","whatsapp","facebook","instagram"]),
  subject: z.string().optional(),
  bodyHandlebars: z.string().min(1)
});

export const campaignUpsertSchema = z.object({
  id: z.string().uuid().optional(),
  name: z.string().min(1),
  channel: z.enum(["email","whatsapp","facebook","instagram"]),
  templateId: z.string().uuid(),
  segmentId: z.string().uuid().optional(),
  manualAudience: z.array(z.object({
    contactId: z.string().uuid().optional(),
    toAddress: z.string().min(3)
  })).optional(),
  abVariantBTemplateId: z.string().uuid().optional(),
  abSplitPercent: z.number().int().min(0).max(50).default(0),
  throttlePerMin: z.number().int().min(1).max(5000).default(600),
  maxSends: z.number().int().positive().optional(),
  scheduledAt: z.string().datetime().optional(),
  defaultData: z.record(z.any()).optional()
});

export const campaignScheduleSchema = z.object({
  campaignId: z.string().uuid(),
  at: z.string().datetime().optional() // se vazio: agora
});

3) Providers (Email + WhatsApp + Meta)

Arquivo: server/modules/marketing/providers.ts

import nodemailer from "nodemailer";
import Handlebars from "handlebars";
import { Twilio } from "twilio";

const smtpTransport = nodemailer.createTransport({
  host: process.env.SMTP_HOST!,
  port: Number(process.env.SMTP_PORT || 587),
  secure: false,
  auth: { user: process.env.SMTP_USER!, pass: process.env.SMTP_PASS! }
});
const SMTP_FROM = process.env.SMTP_FROM || "No Reply <no-reply@example.com>";

const twilio = new Twilio(process.env.TWILIO_ACCOUNT_SID || "", process.env.TWILIO_AUTH_TOKEN || "");
const TWILIO_WHATSAPP_FROM = process.env.TWILIO_WHATSAPP_FROM || "whatsapp:+14155238886";

export type RenderInput = {
  subject?: string;
  bodyHandlebars: string;
  data: Record<string, any>;
};
export function renderTemplate({ subject, bodyHandlebars, data }: RenderInput) {
  const body = Handlebars.compile(bodyHandlebars)(data);
  const subj = subject ? Handlebars.compile(subject)(data) : undefined;
  return { subject: subj, body };
}

export async function sendEmail(to: string, subject: string, html: string) {
  const info = await smtpTransport.sendMail({ from: SMTP_FROM, to, subject, html });
  return { providerMessageId: info.messageId };
}

export async function sendWhatsapp(to: string, text: string) {
  const msg = await twilio.messages.create({ from: TWILIO_WHATSAPP_FROM, to, body: text });
  return { providerMessageId: msg.sid };
}

// para facebook/instagram (envio) normalmente usa Graph API. Aqui deixamos stubs prontos.
export async function sendFacebook(toUserId: string, text: string) {
  // TODO: implementar com Graph API e Page Access Token
  return { providerMessageId: "fb_"+Date.now() };
}
export async function sendInstagram(toUserId: string, text: string) {
  // TODO: implementar com Graph API e IG Business Account
  return { providerMessageId: "ig_"+Date.now() };
}

4) Serviço principal (criar/editar template, campanha, agendar e executar)

Arquivo: server/modules/marketing/service.ts

import { db } from "../../db";
import { mkTemplates, mkCampaigns, mkSends, mkEvents } from "@shared/schema.marketing";
import { and, eq, desc, sql } from "drizzle-orm";
import { templateUpsertSchema, campaignUpsertSchema, campaignScheduleSchema } from "./validators";
import { SegmentsEngine } from "../crm/segments";
import { sendEmail, sendWhatsapp, sendFacebook, sendInstagram, renderTemplate } from "./providers";
import IORedis from "ioredis";
import { Queue, Worker, Job } from "bullmq";
import Handlebars from "handlebars";

type Ctx = { tenantId: string; role: string; userId: string };

const connection = new IORedis(process.env.REDIS_URL || "redis://localhost:6379");
export const CampaignQueue = new Queue("marketing-campaigns", { connection });

export const MarketingService = {
  // ---------------- TEMPLATES ----------------
  async upsertTemplate(ctx: Ctx, input: unknown) {
    const d = templateUpsertSchema.parse(input);
    if (d.id) {
      await db.update(mkTemplates).set({ ...d, updatedAt: new Date() })
        .where(and(eq(mkTemplates.id, d.id), eq(mkTemplates.tenantId, ctx.tenantId)));
      return { id: d.id, updated: true };
    }
    const [ins] = await db.insert(mkTemplates).values({ ...d, tenantId: ctx.tenantId }).returning();
    return { id: ins.id, created: true };
  },

  async listTemplates(ctx: Ctx) {
    const rows = await db.select().from(mkTemplates).where(eq(mkTemplates.tenantId, ctx.tenantId)).orderBy(desc(mkTemplates.createdAt));
    return { rows };
  },

  // ---------------- CAMPAIGNS ----------------
  async upsertCampaign(ctx: Ctx, input: unknown) {
    const d = campaignUpsertSchema.parse(input);
    const payload: any = {
      tenantId: ctx.tenantId,
      name: d.name,
      channel: d.channel,
      templateId: d.templateId,
      segmentId: d.segmentId || null,
      manualAudienceJson: d.manualAudience ? JSON.stringify(d.manualAudience) : null,
      abVariantBTemplateId: d.abVariantBTemplateId || null,
      abSplitPercent: d.abSplitPercent ?? 0,
      throttlePerMin: d.throttlePerMin ?? 600,
      maxSends: d.maxSends || null,
      scheduledAt: d.scheduledAt ? new Date(d.scheduledAt) : null,
      defaultDataJson: d.defaultData ? JSON.stringify(d.defaultData) : null,
      status: "draft"
    };
    if (d.id) {
      await db.update(mkCampaigns).set({ ...payload, updatedAt: new Date() })
        .where(and(eq(mkCampaigns.id, d.id), eq(mkCampaigns.tenantId, ctx.tenantId)));
      return { id: d.id, updated: true };
    }
    const [ins] = await db.insert(mkCampaigns).values(payload).returning();
    return { id: ins.id, created: true };
  },

  async scheduleCampaign(ctx: Ctx, input: unknown) {
    const d = campaignScheduleSchema.parse(input);
    const when = d.at ? new Date(d.at) : new Date();
    await db.execute(sql`update mk_campaigns set status='scheduled', scheduled_at=${when}, updated_at=now() where id=${d.campaignId} and tenant_id=${ctx.tenantId}`);
    await CampaignQueue.add("run-campaign", { tenantId: ctx.tenantId, campaignId: d.campaignId }, { delay: Math.max(0, when.getTime() - Date.now()) });
    return { scheduled: true, at: when.toISOString() };
  }
};

// ============== WORKER: Execução da campanha ==============

type RunCampaignJob = { tenantId: string; campaignId: string };
export const CampaignWorker = new Worker<RunCampaignJob>("marketing-campaigns", async (job: Job<RunCampaignJob>) => {
  const { tenantId, campaignId } = job.data;

  // marca running
  await db.execute(sql`update mk_campaigns set status='running', started_at=now() where id=${campaignId} and tenant_id=${tenantId}`);

  // carrega campanha + templates
  const [cpg] = await db.select().from(mkCampaigns).where(and(eq(mkCampaigns.id, campaignId), eq(mkCampaigns.tenantId, tenantId))).limit(1);
  if (!cpg) return;

  const [tplA] = await db.select().from(mkTemplates).where(and(eq(mkTemplates.id, cpg.templateId), eq(mkTemplates.tenantId, tenantId))).limit(1);
  const tplB = cpg.abVariantBTemplateId ? (await db.select().from(mkTemplates).where(and(eq(mkTemplates.id, cpg.abVariantBTemplateId), eq(mkTemplates.tenantId, tenantId))).limit(1))[0] : null;

  // resolve audiência
  let audience: Array<{ contactId?: string; toAddress: string }> = [];
  if (cpg.segmentId) {
    // usa engine dos segments (CRM)
    const out = await SegmentsEngine.runSegment(tenantId, cpg.segmentId, { page: 1, pageSize: 100000 });
    if (cpg.channel === "email" && out.entity === "contacts") {
      audience = (out.rows as any[]).filter(r => r.email).map(r => ({ contactId: r.id, toAddress: r.email }));
    } else if (cpg.channel === "whatsapp" && out.entity === "contacts") {
      audience = (out.rows as any[]).filter(r => r.phone).map(r => ({ contactId: r.id, toAddress: r.phone }));
    } else {
      // fallback simples (usar campo apropriado depois)
      audience = (out.rows as any[]).map((r: any) => ({ contactId: r.id, toAddress: r.email || r.phone || String(r.id) }));
    }
  } else if (cpg.manualAudienceJson) {
    audience = JSON.parse(cpg.manualAudienceJson);
  }

  // aplica maxSends
  if (cpg.maxSends && audience.length > cpg.maxSends) {
    audience = audience.slice(0, cpg.maxSends);
  }

  // split A/B
  const splitB = Math.floor((audience.length * (cpg.abSplitPercent || 0)) / 100);
  const audB = splitB > 0 ? audience.slice(0, splitB) : [];
  const audA = splitB > 0 ? audience.slice(splitB) : audience;

  const defaultData = cpg.defaultDataJson ? JSON.parse(cpg.defaultDataJson) : {};

  // throttle simples
  const perMin = Math.max(1, cpg.throttlePerMin || 600);
  const delayBetweenMs = Math.floor(60000 / perMin);

  // helper de envio
  async function sendOne(to: string, variant: "A" | "B", contactId?: string) {
    try {
      const tpl = (variant === "B" && tplB) ? tplB : tplA!;
      const rendered = renderTemplate({
        subject: tpl.subject || "",
        bodyHandlebars: tpl.bodyHandlebars,
        data: { ...defaultData, contactId, to: to }
      });

      // tracking (email): injeta pixel e reescreve links
      let html = rendered.body;
      if (cpg.channel === "email") {
        const sid = cryptoRandomId();
        html = rewriteLinksWithTracking(html, sid);
        html += `<img src="/api/marketing/t.gif?sid=${sid}" width="1" height="1" style="display:none" />`;
        // grava send (pré)
        const [s] = await db.insert(mkSends).values({
          tenantId, campaignId: cpg.id, contactId: contactId || null,
          toAddress: to, channel: "email", templateId: tpl.id, abVariant: variant
        }).returning();
        const resp = await sendEmail(to, rendered.subject || "", html);
        await db.execute(sql`update mk_sends set provider_msg_id=${resp.providerMessageId}, sent_at=now() where id=${s.id}`);
        await db.insert(mkEvents).values({ tenantId, sendId: s.id, type: "delivered", meta: JSON.stringify({ providerMessageId: resp.providerMessageId }) });
        return;
      }

      if (cpg.channel === "whatsapp") {
        const [s] = await db.insert(mkSends).values({
          tenantId, campaignId: cpg.id, contactId: contactId || null,
          toAddress: to, channel: "whatsapp", templateId: tpl.id, abVariant: variant
        }).returning();
        const resp = await sendWhatsapp(to, stripHtmlToText(html));
        await db.execute(sql`update mk_sends set provider_msg_id=${resp.providerMessageId}, sent_at=now() where id=${s.id}`);
        await db.insert(mkEvents).values({ tenantId, sendId: s.id, type: "delivered", meta: JSON.stringify(resp) });
        return;
      }

      if (cpg.channel === "facebook") {
        const [s] = await db.insert(mkSends).values({
          tenantId, campaignId: cpg.id, contactId: contactId || null,
          toAddress: to, channel: "facebook", templateId: tpl.id, abVariant: variant
        }).returning();
        const resp = await sendFacebook(to, stripHtmlToText(html));
        await db.execute(sql`update mk_sends set provider_msg_id=${resp.providerMessageId}, sent_at=now() where id=${s.id}`);
        await db.insert(mkEvents).values({ tenantId, sendId: s.id, type: "delivered", meta: JSON.stringify(resp) });
        return;
      }

      if (cpg.channel === "instagram") {
        const [s] = await db.insert(mkSends).values({
          tenantId, campaignId: cpg.id, contactId: contactId || null,
          toAddress: to, channel: "instagram", templateId: tpl.id, abVariant: variant
        }).returning();
        const resp = await sendInstagram(to, stripHtmlToText(html));
        await db.execute(sql`update mk_sends set provider_msg_id=${resp.providerMessageId}, sent_at=now() where id=${s.id}`);
        await db.insert(mkEvents).values({ tenantId, sendId: s.id, type: "delivered", meta: JSON.stringify(resp) });
        return;
      }
    } catch (e: any) {
      // erro ao enviar — registra
      // (Para simplicidade, não interrompe a campanha)
    }
  }

  // executa envios com throttling
  for (const aud of audA) { await sendOne(aud.toAddress, "A", aud.contactId); await sleep(delayBetweenMs); }
  for (const aud of audB) { await sendOne(aud.toAddress, "B", aud.contactId); await sleep(delayBetweenMs); }

  // finaliza
  await db.execute(sql`update mk_campaigns set status='finished', finished_at=now() where id=${campaignId} and tenant_id=${tenantId}`);
}, { connection });

// -------------- utils --------------
function sleep(ms: number) { return new Promise(r => setTimeout(r, ms)); }
function stripHtmlToText(html: string) { return html.replace(/<[^>]+>/g, " ").replace(/\s+/g, " ").trim(); }
function cryptoRandomId() { return Math.random().toString(36).slice(2) + Date.now().toString(36); }

// tracking: reescreve links <a href="URL"> para /api/marketing/click?sid=...&u=...
function rewriteLinksWithTracking(html: string, sid: string) {
  return html.replace(/<a\s+([^>]*?)href="([^"]+)"([^>]*)>/gi, (m, pre, href, post) => {
    const enc = encodeURIComponent(href);
    return `<a ${pre} href="/api/marketing/click?sid=${sid}&u=${enc}" ${post}>`;
  });
}


Observação: para opt-in/quiet hours usaremos a tabela contact_preferences na rota de pre-flight (abaixo). Se quiser, adiciono um guard dentro do Worker para filtrar cada destinatário também (é simples de estender).

5) Rotas — CRUD + Tracking + Sched

Arquivo: server/modules/marketing/routes.ts

import type { Express, Request, Response } from "express";
import { MarketingService, CampaignQueue } from "./service";
import { db } from "../../db";
import { mkCampaigns, mkSends, mkEvents, contactPreferences } from "@shared/schema.marketing";
import { and, eq, desc } from "drizzle-orm";

function getCtx(req: Request) {
  const tenantId = (req as any).tenantId || (res as any)?.locals?.tenantId || process.env.PRIMARY_TENANT_ID!;
  const role = (req.headers["x-role"] as string) || "admin";
  const userId = (req.headers["x-user-id"] as string) || "system";
  return { tenantId, role, userId };
}

export function registerMarketingRoutes(app: Express) {
  // templates
  app.post("/api/mkt/templates.upsert", async (req, res) => {
    try { res.json(await MarketingService.upsertTemplate(getCtx(req), req.body)); }
    catch (e: any) { res.status(400).json({ error: e?.message }); }
  });
  app.get("/api/mkt/templates.list", async (req, res) => {
    try { res.json(await MarketingService.listTemplates(getCtx(req))); }
    catch (e: any) { res.status(400).json({ error: e?.message }); }
  });

  // campaigns
  app.post("/api/mkt/campaigns.upsert", async (req, res) => {
    try { res.json(await MarketingService.upsertCampaign(getCtx(req), req.body)); }
    catch (e: any) { res.status(400).json({ error: e?.message }); }
  });
  app.post("/api/mkt/campaigns.schedule", async (req, res) => {
    try { res.json(await MarketingService.scheduleCampaign(getCtx(req), req.body)); }
    catch (e: any) { res.status(400).json({ error: e?.message }); }
  });
  app.get("/api/mkt/campaigns.list", async (req, res) => {
    try {
      const ctx = getCtx(req);
      const rows = await db.select().from(mkCampaigns).where(eq(mkCampaigns.tenantId, ctx.tenantId)).orderBy(desc(mkCampaigns.createdAt));
      res.json({ rows });
    } catch (e: any) { res.status(400).json({ error: e?.message }); }
  });

  // tracking pixel (1x1 GIF)
  app.get("/api/marketing/t.gif", async (req, res) => {
    try {
      const sid = String(req.query.sid || "");
      // se quiser, localize mkSends por algum mapa sid->sendId (poderia ser redis). Aqui só registra evento "opened" com meta=sid.
      await db.insert(mkEvents).values({ tenantId: process.env.PRIMARY_TENANT_ID!, sendId: "unknown", type: "opened", meta: JSON.stringify({ sid }) });
      const gif = Buffer.from("R0lGODlhAQABAPAAAP///wAAACwAAAAAAQABAAACAkQBADs=", "base64");
      res.setHeader("Content-Type", "image/gif"); res.setHeader("Cache-Control","no-store"); res.end(gif);
    } catch { res.end(); }
  });

  // click redirect
  app.get("/api/marketing/click", async (req, res) => {
    const sid = String(req.query.sid || "");
    const u = String(req.query.u || "");
    await db.insert(mkEvents).values({ tenantId: process.env.PRIMARY_TENANT_ID!, sendId: "unknown", type: "clicked", meta: JSON.stringify({ sid, u: decodeURIComponent(u) }) });
    res.redirect(decodeURIComponent(u));
  });

  // métricas por campanha
  app.get("/api/mkt/campaigns.metrics", async (req, res) => {
    try {
      const ctx = getCtx(req);
      const campaignId = String(req.query.campaignId);
      const sends = await db.select().from(mkSends).where(and(eq(mkSends.tenantId, ctx.tenantId), eq(mkSends.campaignId, campaignId)));
      const events = await db.select().from(mkEvents).where(eq(mkEvents.tenantId, ctx.tenantId)).orderBy(desc(mkEvents.createdAt));
      res.json({ sends, events });
    } catch (e: any) { res.status(400).json({ error: e?.message }); }
  });

  // LGPD preferences (upsert)
  app.post("/api/mkt/contact-prefs.set", async (req, res) => {
    try {
      const ctx = getCtx(req);
      const { contactId, emailOptIn, whatsappOptIn, facebookOptIn, instagramOptIn, quietHoursStart, quietHoursEnd } = req.body || {};
      await db.execute(`
        insert into contact_preferences (tenant_id, contact_id, email_optin, whatsapp_optin, facebook_optin, instagram_optin, quiet_start, quiet_end, updated_at)
        values ($1,$2,coalesce($3,true),coalesce($4,true),coalesce($5,false),coalesce($6,false),coalesce($7,22),coalesce($8,8), now())
        on conflict (tenant_id, contact_id) do update set
          email_optin=excluded.email_optin, whatsapp_optin=excluded.whatsapp_optin,
          facebook_optin=excluded.facebook_optin, instagram_optin=excluded.instagram_optin,
          quiet_start=excluded.quiet_start, quiet_end=excluded.quiet_end, updated_at=now()
      `, [ctx.tenantId, contactId, emailOptIn, whatsappOptIn, facebookOptIn, instagramOptIn, quietHoursStart, quietHoursEnd]);
      res.json({ ok: true });
    } catch (e:any) { res.status(400).json({ error: e?.message }); }
  });
}


Registro das rotas: adicione em server/routes.ts:

import { registerMarketingRoutes } from "./modules/marketing/routes";

export function registerRoutes(app: Express) {
  app.use("/api", singleTenantMiddleware);
  // ... outros módulos
  registerMarketingRoutes(app);
}

6) Pré-filtro LGPD e Quiet Hours (opcional — guard no Worker)

Se quiser bloquear envio fora do horário do contato, adicione no começo do sendOne (em service.ts):

// (antes de renderTemplate)
const nowHour = new Date().getHours();
const [pref] = await db.select().from(contactPreferences).where(and(
  eq(contactPreferences.tenantId, tenantId),
  eq(contactPreferences.contactId, contactId || "00000000-0000-0000-0000-000000000000")
)).limit(1);

// Opt-in por canal
if (cpg.channel === "email" && pref && !pref.emailOptIn) return;
if (cpg.channel === "whatsapp" && pref && !pref.whatsappOptIn) return;
// quiet hours
if (pref) {
  const s = pref.quietHoursStart ?? 22, e = pref.quietHoursEnd ?? 8;
  const isQuiet = s < e ? (nowHour >= s && nowHour < e) : (nowHour >= s || nowHour < e);
  if (isQuiet) return; // pule agora; em produção você poderia re-enfileirar para depois
}

7) Como usar (passo a passo rápido)

Criar Template de Email

POST /api/mkt/templates.upsert
{
  "name": "Boas-vindas",
  "channel": "email",
  "subject": "Oi, {{firstName}}! Bem-vinda ao Yes You Deserve",
  "bodyHandlebars": "<h1>Olá, {{firstName}}</h1><p>Seu cupom é <b>{{coupon}}</b></p><p><a href='https://yesyoudeserve.tours'>Site</a></p>"
}


Criar Campanha usando um Segment de CRM (ex.: contatos Gmail)

POST /api/mkt/campaigns.upsert
{
  "name": "Boas-vindas Outubro",
  "channel": "email",
  "templateId": "<TPL_ID>",
  "segmentId": "<SEGMENT_ID_CONTACTS>",
  "abSplitPercent": 20,
  "throttlePerMin": 300,
  "defaultData": { "coupon": "YYD10", "firstName": "cliente" }
}


Agendar (agora)

POST /api/mkt/campaigns.schedule
{ "campaignId": "<CAMP_ID>" }


Acompanhar

GET /api/mkt/campaigns.metrics?campaignId=<CAMP_ID>


LGPD preferências por contato (exemplo)

POST /api/mkt/contact-prefs.set
{
  "contactId": "<CONTACT_ID>",
  "emailOptIn": true,
  "whatsappOptIn": false,
  "quietHoursStart": 21, "quietHoursEnd": 9
}

8) Qualidade de produção

Single-Tenant em todas as tabelas e rotas.

Fila BullMQ com throttling por campanha.

A/B split por % simples.

Tracking de opens/clicks (pixel + redirect).

LGPD/opt-in e quiet hours por contato.

Providers desacoplados (SMTP/Nodemailer + Twilio WhatsApp; Meta pronto para habilitar Graph API).

Segmentação nativa via SegmentsEngine do CRM.